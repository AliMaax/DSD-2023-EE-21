# FPGA Circuit Implementation

## Overview
This project implements an FPGA circuit using SystemVerilog. The design is described in [RTL_File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/RTL/lab2task.sv), and the pin constraints are defined in [Constraints File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Constraints/lab2task.xdc). A schematic representation is included in a [Draw.io File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Docs/Lab2.drawio) `or` [ScreenShot](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Docs/Screenshot%202025-02-04%20174639.png).

## Files Included
- [RTL_File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/RTL/lab2task.sv) – SystemVerilog code for the FPGA implementation
- [Constraints File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Constraints/lab2task.xdc) – Pin assignments and constraints
- [Draw.io File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Docs/Lab2.drawio) `or` [ScreenShot](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Docs/Screenshot%202025-02-04%20174639.png). – Circuit schematic for reference

## Prerequisites
- **FPGA Board:** Nexys A7 100T
- **Software:** Vivado
- **Language:** SystemVerilog

## How to Build and Run
1. Open the FPGA design software i.e.Vivado
2. Create a new project and add [RTL_File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/RTL/lab2task.sv)
3. Assign constraints using [Constraints File](https://github.com/AliMaax/DSD-2023-EE-21/blob/master/Lab2/Constraints/lab2task.xdc)
4. Run synthesis, implementation, and bitstream generation
5. To load the bit file generated by the Generate Bitstream step:

    1. Go to the folder where you created the project. There you will find different folders with the starting name same as your project name.
    2. Go to the your_project_name.runs folder, then impl_1 folder.
    3. In the search bar, you will write .bit and hit enter. 
    4. It will display your bit file with the name same as your top module. module_name.bit. 
    5. Copy that into a USB.
    6. You will  attach that USB to the FPGA, then hit the program button.
    7. When it will have loaded, the Done LED will turn on. 
6. Or you can Program the FPGA with the generated bitstream


## Results and Observations
### For X:

| a | b | c | Inverted C (~c)| OR gate (a \| b) | XOR gate x = (~c) ^ (a \| b)|
|---|---|---|----------------|------------------|-----------------------------|
| 0 | 0 | 0 |       1        |         0        |               1             |
| 0 | 0 | 1 |       0        |         0        |               0             |
| 0 | 1 | 0 |       1        |         1        |               0             |
| 0 | 1 | 1 |       0        |         1        |               1             |
| 1 | 0 | 0 |       1        |         1        |               0             |
| 1 | 0 | 1 |       0        |         1        |               1             |
| 1 | 1 | 0 |       1        |         1        |               0             |
| 1 | 1 | 1 |       0        |         1        |               1             |

### For Y:

| a | b | c | OR gate (a \| b) | NAND gate ~(a & b) | XOR gate (~(a & b)) ^ (a \| b) | AND gate y = (a \| b) & (~(a & b)) ^ (a \| b) |
|---|---|---|------------------|---------------------|-------------------------------|---------------------------------------------|
| 0 | 0 | 0 | 0                | 1                   | 1                             | 0                                           |
| 0 | 0 | 1 | 0                | 1                   | 1                             | 0                                           |
| 0 | 1 | 0 | 1                | 1                   | 0                             | 0                                           |
| 0 | 1 | 1 | 1                | 1                   | 0                             | 0                                           |
| 1 | 0 | 0 | 1                | 1                   | 0                             | 0                                           |
| 1 | 0 | 1 | 1                | 1                   | 0                             | 0                                           |
| 1 | 1 | 0 | 1                | 0                   | 1                             | 1                                           |
| 1 | 1 | 1 | 1                | 0                   | 1                             | 1                                           |

#### Observations
1. For X output:
    1. X follows the XOR pattern between (~c) and (a | b).
    2. If both are 0 or both are 1, then X = 0.
    3. If they are different, then X = 1.
2. For Y output:
    1. The final Y value is computed using an AND operation between the OR gate output and the XOR gate output.
    2. This ensures that Y is only 1 when a and b inputs  are 


